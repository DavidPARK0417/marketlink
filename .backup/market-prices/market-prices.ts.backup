"server-only";

/**
 * @file lib/api/market-prices.ts
 * @description ì‹œì„¸ ì¡°íšŒ API í•¨ìˆ˜
 *
 * âš ï¸ ì„œë²„ ì „ìš©: ì´ íŒŒì¼ì€ ì„œë²„ ì‚¬ì´ë“œì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” íƒ€ì…ë§Œ importí•˜ë ¤ë©´ lib/api/market-prices-types.tsë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.
 *
 * KAMIS Open APIë¥¼ ì‚¬ìš©í•˜ì—¬ ë†ìˆ˜ì‚°ë¬¼ ì‹œì„¸ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 * API ì—”ë“œí¬ì¸íŠ¸: http://www.kamis.or.kr/service/price/xml.do
 *
 * ì£¼ìš” ê¸°ëŠ¥:
 * 1. ì‹œì„¸ ì¡°íšŒ (ì§€ì—­ ê²½ë§¤ì‹œì¥, í’ˆëª©ëª… ê¸°ë°˜)
 * 2. ìµœê·¼ 1ì£¼ì¼ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ
 * 3. ì£¼ìš” ë„ë§¤ì‹œì¥ ë° í’ˆëª© ì¹´í…Œê³ ë¦¬ ì •ì˜
 *
 * @dependencies
 * - í™˜ê²½ ë³€ìˆ˜: KAMIS_CERT_ID, KAMIS_CERT_KEY
 * - lib/api/market-prices-types.ts (íƒ€ì… ì •ì˜)
 *
 * @example
 * ```tsx
 * // ì„œë²„ ì»´í¬ë„ŒíŠ¸ ë˜ëŠ” API Routeì—ì„œ
 * import { getMarketPrices } from '@/lib/api/market-prices';
 *
 * const prices = await getMarketPrices({
 *   itemName: 'ì‚¬ê³¼',
 *   countryCode: '1101', // ì„œìš¸
 * });
 * ```
 */

// íƒ€ì…ì€ ë³„ë„ íŒŒì¼ì—ì„œ import
import type {
  MarketPriceParams,
  PriceItem,
  PriceTrendItem,
} from "./market-prices-types";

// íƒ€ì…ì„ ë‹¤ì‹œ export (í•˜ìœ„ í˜¸í™˜ì„±)
export type { MarketPriceParams, PriceItem, PriceTrendItem };

// API ì‘ë‹µ íƒ€ì… (ì‹¤ì œ ì‘ë‹µ êµ¬ì¡°ì— ë§ê²Œ ì¡°ì • í•„ìš”)
interface ApiResponse {
  response?: {
    header?: {
      resultCode?: string;
      resultMsg?: string;
    };
    body?: {
      items?: {
        item?: any | any[];
      };
      totalCount?: number;
    };
  };
  [key: string]: any; // ê¸°íƒ€ í•„ë“œ í—ˆìš©
}

/**
 * ë‚ ì§œ ë²”ìœ„ ë‚´ì˜ ëª¨ë“  ë‚ ì§œë¥¼ ë°°ì—´ë¡œ ë°˜í™˜
 * @param from YYYY-MM-DD
 * @param to YYYY-MM-DD
 */
function getDatesInRange(from: string, to: string): string[] {
  const dates: string[] = [];
  const startDate = new Date(from);
  const endDate = new Date(to);

  const currentDate = new Date(startDate);
  while (currentDate <= endDate) {
    const dateStr = currentDate.toISOString().split("T")[0];
    dates.push(dateStr);
    currentDate.setDate(currentDate.getDate() + 1);
  }

  return dates;
}

/**
 * KAMIS API í˜¸ì¶œ í•¨ìˆ˜
 *
 * KAMIS Open APIë¥¼ ì‚¬ìš©í•˜ì—¬ ë†ìˆ˜ì‚°ë¬¼ ì‹œì„¸ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
 *
 * @param params - ì¡°íšŒ íŒŒë¼ë¯¸í„°
 * @returns ì‹œì„¸ ì •ë³´ ë°°ì—´
 */
async function fetchMarketPricesFromKAMIS(
  params: MarketPriceParams = {},
): Promise<PriceItem[]> {
  // í™˜ê²½ë³€ìˆ˜ì—ì„œ ì¸ì¦ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  const certId = process.env.KAMIS_CERT_ID;
  const certKey = process.env.KAMIS_CERT_KEY?.trim().replace(
    /^["']|["']$/g,
    "",
  );

  if (!certId || !certKey) {
    throw new Error(
      "KAMIS API ì¸ì¦ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. KAMIS_CERT_IDì™€ KAMIS_CERT_KEYë¥¼ í™•ì¸í•˜ì„¸ìš”.",
    );
  }

  // ë‚ ì§œ ë²”ìœ„ ì„¤ì •
  let startDay: string;
  let endDay: string;

  if (params.dateRange) {
    startDay = params.dateRange.from;
    endDay = params.dateRange.to;
  } else if (params.startDay && params.endDay) {
    startDay = params.startDay;
    endDay = params.endDay;
  } else if (params.date) {
    // ë‹¨ì¼ ë‚ ì§œë¥¼ ë²”ìœ„ë¡œ ë³€í™˜
    startDay = params.date;
    endDay = params.date;
  } else {
    // ê¸°ë³¸ê°’: ìµœê·¼ 30ì¼ (ë” ë§ì€ ë°ì´í„° í™•ë³´)
    const today = new Date();
    const monthAgo = new Date(today);
    monthAgo.setDate(today.getDate() - 30);
    startDay = monthAgo.toISOString().split("T")[0];
    endDay = today.toISOString().split("T")[0];
  }

  // ğŸ”¥ í•µì‹¬ ë³€ê²½: ì½”ë“œí‘œ ê¸°ë°˜ìœ¼ë¡œ ì •í™•í•œ í’ˆëª© ì½”ë“œ ì°¾ê¸°
  let itemCode = params.itemCode;
  let itemCategoryCode = params.itemCategoryCode;
  let productRankCode = params.productRankCode;

  console.group("ğŸ“Š [KAMIS API] ì‹œì„¸ ì¡°íšŒ (ì½”ë“œí‘œ ê¸°ë°˜ ë§¤í•‘)");
  console.log("í’ˆëª©ëª…:", params.itemName || "ì—†ìŒ");
  console.log("í’ˆëª©ë²ˆí˜¸:", params.productNo || "ì—†ìŒ");
  console.log("ë‹¨ìœ„ íƒ€ì…:", params.unitType || "ì—†ìŒ");
  console.log("ê¸°ì¡´ í’ˆëª© ì½”ë“œ:", itemCode || "ì—†ìŒ");
  console.log("ê¸°ì¡´ ë¶€ë¥˜ ì½”ë“œ:", itemCategoryCode || "ì—†ìŒ");

  // ğŸ†• ì½”ë“œí‘œ ê¸°ë°˜ ì½”ë“œ ì°¾ê¸° (ìš°ì„ ìˆœìœ„ 1)
  if (params.productNo) {
    // í’ˆëª©ë²ˆí˜¸ë¡œ ì§ì ‘ ì¡°íšŒ
    try {
      const { getProductCodeByNo } = await import(
        "@/lib/supabase/queries/product-codes"
      );
      const { convertToKAMISCode } = await import("@/lib/api/product-codes");

      const productCode = await getProductCodeByNo(params.productNo);
      if (productCode) {
        const kamisCode = convertToKAMISCode(productCode);
        itemCode = kamisCode.itemCode;
        itemCategoryCode = kamisCode.itemCategoryCode;
        productRankCode = kamisCode.productRankCode;
        console.log(
          `âœ… [ì½”ë“œí‘œ ë§¤í•‘] í’ˆëª©ë²ˆí˜¸ ${params.productNo} â†’ ì½”ë“œ ${itemCode}, ë¶€ë¥˜ ${itemCategoryCode}, ë“±ê¸‰ ${productRankCode}`,
        );
      }
    } catch (error) {
      console.warn("âš ï¸ [ì½”ë“œí‘œ ì¡°íšŒ] ì˜¤ë¥˜:", error);
    }
  } else if (params.itemName && !itemCode) {
    // í’ˆëª©ëª…ìœ¼ë¡œ ì½”ë“œí‘œ ê²€ìƒ‰
    try {
      const { searchProductCodes } = await import(
        "@/lib/supabase/queries/product-codes"
      );
      const { findProductCodes, convertToKAMISCode } = await import(
        "@/lib/api/product-codes"
      );

      const codes = await searchProductCodes(params.itemName, 10);
      if (codes.length > 0) {
        // ë‹¨ìœ„ íƒ€ì… í•„í„°ë§
        const filteredCodes = findProductCodes(
          params.itemName,
          params.unitType,
          codes,
        );

        if (filteredCodes.length > 0) {
          // ì²« ë²ˆì§¸ ë§¤ì¹­ ê²°ê³¼ ì‚¬ìš©
          const productCode = filteredCodes[0];
          const kamisCode = convertToKAMISCode(productCode);
          itemCode = kamisCode.itemCode;
          itemCategoryCode = kamisCode.itemCategoryCode;
          productRankCode = kamisCode.productRankCode;
          console.log(
            `âœ… [ì½”ë“œí‘œ ë§¤í•‘] "${params.itemName}" â†’ í’ˆëª©ë²ˆí˜¸ ${productCode.productNo}, ì½”ë“œ ${itemCode}, ë¶€ë¥˜ ${itemCategoryCode}, ë“±ê¸‰ ${productRankCode}`,
          );
        }
      }
    } catch (error) {
      console.warn("âš ï¸ [ì½”ë“œí‘œ ê²€ìƒ‰] ì˜¤ë¥˜:", error);
    }

    // ì½”ë“œí‘œì—ì„œ ì°¾ì§€ ëª»í•œ ê²½ìš° productInfo APIë¡œ fallback
    if (!itemCode) {
      console.log("ğŸ” [í’ˆëª© ì½”ë“œ ê²€ìƒ‰] productInfo APIë¡œ ì •í™•í•œ ì½”ë“œ ì°¾ê¸°");
      const codeInfo = await getItemCodeFromNameUsingAPI(params.itemName);

      if (codeInfo) {
        itemCode = codeInfo.itemCode;
        itemCategoryCode = codeInfo.categoryCode || itemCategoryCode;
        console.log(
          `âœ… [í’ˆëª© ì½”ë“œ ê²€ìƒ‰] ë°œê²¬: "${params.itemName}" â†’ ì½”ë“œ ${itemCode}, ë¶€ë¥˜ ${itemCategoryCode}`,
        );
      } else {
        console.warn(
          `âš ï¸ [í’ˆëª© ì½”ë“œ ê²€ìƒ‰] "${params.itemName}"ì— ëŒ€í•œ í’ˆëª© ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ`,
        );
        // ë¶€ë¥˜ ì½”ë“œëŠ” ê¸°ì¡´ ë¡œì§ìœ¼ë¡œ ì¶”ì • ì‹œë„
        if (!itemCategoryCode) {
          itemCategoryCode = getItemCategoryCodeFromName(params.itemName);
          console.log(
            `ğŸ“‹ [ë¶€ë¥˜ ì½”ë“œ ì¶”ì •] "${params.itemName}" â†’ ë¶€ë¥˜ ${
              itemCategoryCode || "ì—†ìŒ"
            }`,
          );
        }
      }
    }
  }

  // ë“±ê¸‰ ì½”ë“œ ì„¤ì •
  if (params.gradeCode && !productRankCode) {
    const { GRADE_CODE_MAP } = await import("@/lib/api/product-codes");
    productRankCode = GRADE_CODE_MAP[params.gradeCode] || "04";
  }

  // í’ˆëª© ì½”ë“œë¡œ ì •í™•í•œ ê²€ìƒ‰
  let items: any[] = [];

  if (itemCode) {
    console.log("ğŸ” [ì‹œì„¸ ì¡°íšŒ] í’ˆëª© ì½”ë“œë¡œ ì •í™•í•œ ê²€ìƒ‰ ì‹œë„");
    items = await fetchKAMISData({
      certKey,
      certId,
      startDay,
      endDay,
      itemCode,
      itemCategoryCode,
      countryCode: params.countryCode || "1101",
      kindCode: params.kindCode || "00",
      productRankCode: productRankCode || params.productRankCode || "04",
    });

    console.log("ğŸ“‹ [ì‹œì„¸ ì¡°íšŒ] ê²°ê³¼:", items.length, "ê±´");

    // í’ˆëª©ëª…ì´ ìˆê³  ê²°ê³¼ê°€ ìˆìœ¼ë©´ í’ˆëª©ëª…ìœ¼ë¡œ í•„í„°ë§ (ì¶”ê°€ ê²€ì¦)
    if (params.itemName && items.length > 0) {
      const keyword = params.itemName.toLowerCase().trim();
      const filtered = items.filter((item: any) => {
        const itemName = (item.itemname || "").toLowerCase();
        const kindName = (item.kindname || "").toLowerCase();
        return itemName.includes(keyword) || kindName.includes(keyword);
      });

      if (filtered.length > 0) {
        console.log("âœ… [ì‹œì„¸ ì¡°íšŒ] í’ˆëª©ëª… í•„í„°ë§ í›„:", filtered.length, "ê±´");
        items = filtered;
      } else {
        console.warn(
          "âš ï¸ [ì‹œì„¸ ì¡°íšŒ] í’ˆëª©ëª…ê³¼ ì¼ì¹˜í•˜ëŠ” ë°ì´í„° ì—†ìŒ (í’ˆëª© ì½”ë“œëŠ” ì •í™•í•˜ì§€ë§Œ í•´ë‹¹ ê¸°ê°„ ë°ì´í„° ì—†ì„ ìˆ˜ ìˆìŒ)",
        );
        // ê²°ê³¼ëŠ” ìœ ì§€ (í’ˆëª© ì½”ë“œê°€ ì •í™•í•˜ë©´ ë°ì´í„°ê°€ ì—†ì„ ìˆ˜ë„ ìˆìŒ)
      }
    }
  } else {
    console.warn("âš ï¸ [ì‹œì„¸ ì¡°íšŒ] í’ˆëª© ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ ì¡°íšŒë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.");
  }

  console.log("ğŸ“‹ [ìµœì¢…] ë°˜í™˜í•  í•­ëª© ìˆ˜:", items.length);
  console.groupEnd();

  // PriceItem í˜•íƒœë¡œ ë³€í™˜
  const result: PriceItem[] = items
    .map((item: any, index: number) => {
      try {
        // KAMIS API ì‹¤ì œ í•„ë“œëª… ì‚¬ìš© (ì†Œë¬¸ì)
        const itemName = item.itemname || "";
        const kindName = item.kindname || "";
        const countyName = item.countyname || "";
        const marketName = item.marketname || "";
        const year = item.yyyy || "";
        const regday = item.regday || ""; // í˜•ì‹: "MM/DD" ë˜ëŠ” "YYYYMMDD"
        const priceStr = item.price || "0"; // ì‰¼í‘œ í¬í•¨ ê°€ëŠ¥: "1,875"

        // ê°€ê²©ì—ì„œ ì‰¼í‘œ ì œê±° í›„ ìˆ«ì ë³€í™˜
        const price = parseFloat(priceStr.replace(/,/g, "")) || 0;

        // ë‚ ì§œ í¬ë§·íŒ… (YYYY-MM-DD)
        let formattedDate = "";
        if (regday && year) {
          if (regday.includes("/")) {
            // "MM/DD" í˜•ì‹ì¸ ê²½ìš°
            const [month, day] = regday.split("/");
            formattedDate = `${year}-${month.padStart(2, "0")}-${day.padStart(
              2,
              "0",
            )}`;
          } else if (regday.length === 8) {
            // "YYYYMMDD" í˜•ì‹ì¸ ê²½ìš°
            formattedDate = `${regday.substring(0, 4)}-${regday.substring(
              4,
              6,
            )}-${regday.substring(6, 8)}`;
          } else {
            formattedDate = `${year}-${regday}`;
          }
        } else if (regday && regday.length === 8) {
          formattedDate = `${regday.substring(0, 4)}-${regday.substring(
            4,
            6,
          )}-${regday.substring(6, 8)}`;
        } else {
          formattedDate = new Date().toISOString().split("T")[0];
        }

        // ë‹¨ìœ„ ì •ë³´ (kindnameì—ì„œ ì¶”ì¶œ ì‹œë„, ì˜ˆ: "ì–‘ë°°ì¶”(1kg)")
        let unit = "kg";
        if (kindName && kindName.includes("(") && kindName.includes(")")) {
          const unitMatch = kindName.match(/\(([^)]+)\)/);
          if (unitMatch) {
            unit = unitMatch[1];
          }
        }

        // í’ˆì§ˆ ë“±ê¸‰ ë³€í™˜ (KAMIS APIì—ì„œëŠ” rank í•„ë“œê°€ ì—†ì„ ìˆ˜ ìˆìŒ)
        const rank = item.rank || item.productrankcode || "";
        let quality: string | undefined;
        if (rank) {
          const rankMap: Record<string, string> = {
            "01": "íŠ¹",
            "02": "ìƒ",
            "03": "ì¤‘",
            "04": "ì „ì²´",
            íŠ¹: "íŠ¹",
            ìƒ: "ìƒ",
            ì¤‘: "ì¤‘",
          };
          quality = rankMap[rank] || rank;
        }

        const priceItem: PriceItem = {
          cfmtnYmd: formattedDate,
          lclsfNm: "", // KAMIS APIì—ì„œ ì œê³µí•˜ì§€ ì•ŠìŒ
          mclsfNm: "", // KAMIS APIì—ì„œ ì œê³µí•˜ì§€ ì•ŠìŒ
          sclsfNm: "",
          avgPrice: price,
          minPrice: price,
          maxPrice: price,
          source: "kamis",
          itemName: itemName,
          varietyName: kindName,
          marketCode: "", // KAMIS APIì—ì„œ ì œê³µí•˜ì§€ ì•ŠìŒ
          marketName: marketName,
          unitName: unit,
          unitQuantity: 1.0,
          quantity: 0, // KAMIS APIì—ì„œ ì œê³µí•˜ì§€ ì•ŠìŒ
          countyName: countyName,
          year: year,
        };

        // qualityëŠ” ì„ íƒì ì´ë¯€ë¡œ ìˆì„ ë•Œë§Œ ì¶”ê°€
        if (quality) {
          priceItem.quality = quality;
        }

        return priceItem;
      } catch (itemError) {
        console.error(
          `âŒ í•­ëª© ${index} ë³€í™˜ ì‹¤íŒ¨:`,
          itemError,
          "ì›ë³¸ ë°ì´í„°:",
          item,
        );
        return null;
      }
    })
    .filter((item): item is PriceItem => item !== null);

  return result;
}

/**
 * KAMIS API ì‹¤ì œ í˜¸ì¶œ í•¨ìˆ˜ (ë‚´ë¶€ í—¬í¼)
 */
async function fetchKAMISData(params: {
  certKey: string;
  certId: string;
  startDay: string;
  endDay: string;
  itemCode?: string;
  itemCategoryCode?: string;
  countryCode: string;
  kindCode: string;
  productRankCode: string;
}): Promise<any[]> {
  const baseUrl = "http://www.kamis.or.kr/service/price/xml.do";
  const queryParams = new URLSearchParams({
    action: "periodWholesaleProductList",
    p_cert_key: params.certKey,
    p_cert_id: params.certId,
    p_startday: params.startDay,
    p_endday: params.endDay,
    p_convert_kg_yn: "Y",
    p_returntype: "json",
    p_kindcode: params.kindCode,
    p_productrankcode: params.productRankCode,
    p_countrycode: params.countryCode,
  });

  // ì„ íƒì  íŒŒë¼ë¯¸í„° ì¶”ê°€
  if (params.itemCategoryCode) {
    queryParams.append("p_itemcategorycode", params.itemCategoryCode);
  }
  if (params.itemCode) {
    queryParams.append("p_itemcode", params.itemCode);
  }

  const apiUrl = `${baseUrl}?${queryParams.toString()}`;

  try {
    const response = await fetch(apiUrl, {
      cache: "no-store",
      headers: {
        Accept: "application/json",
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error("âŒ API ì˜¤ë¥˜ ì‘ë‹µ:", errorText);
      throw new Error(
        `KAMIS API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status} ${response.statusText}`,
      );
    }

    const data: any = await response.json();

    // ì‘ë‹µ êµ¬ì¡° íŒŒì‹±
    const items: any[] = [];

    // ì‘ë‹µ êµ¬ì¡° í™•ì¸ ë° íŒŒì‹±
    // KAMIS API ì‘ë‹µ êµ¬ì¡°: { condition: [...], data: { error_code: "...", item: [...] } }
    if (data.data) {
      // error_code í™•ì¸
      const errorCode = data.data.error_code;
      if (errorCode && errorCode !== "000") {
        console.warn("âš ï¸ [KAMIS API] ì—ëŸ¬ ì½”ë“œ:", errorCode);

        // ì—ëŸ¬ ì½”ë“œ "001"ì€ íŒŒë¼ë¯¸í„° ì˜¤ë¥˜ë¥¼ ì˜ë¯¸
        if (errorCode === "001") {
          console.error(
            "âŒ [KAMIS API] íŒŒë¼ë¯¸í„° ì˜¤ë¥˜: null ê°’ì„ ì „ë‹¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
          );
          console.error("ğŸ“‹ [KAMIS API] ìš”ì²­ íŒŒë¼ë¯¸í„° í™•ì¸ í•„ìš”:", {
            itemCode: params.itemCode,
            itemCategoryCode: params.itemCategoryCode,
            countryCode: params.countryCode,
          });
        }
      }

      // data.data.item ë°°ì—´ì—ì„œ ì‹¤ì œ ê±°ë˜ ë°ì´í„°ë§Œ ì¶”ì¶œ
      if (data.data.item) {
        const itemData = data.data.item;

        if (Array.isArray(itemData)) {
          // í‰ê· /í‰ë…„ ë°ì´í„° ì œì™¸
          const actualItems = itemData.filter((item: any) => {
            const countyName = item.countyname || "";
            return (
              countyName &&
              countyName !== "í‰ê· " &&
              countyName !== "í‰ë…„" &&
              item.itemname
            ); // itemnameì´ ìˆëŠ” ê²ƒë§Œ
          });
          items.push(...actualItems);
        } else if (itemData && typeof itemData === "object") {
          // ë‹¨ì¼ í•­ëª©ì¸ ê²½ìš°
          const countyName = itemData.countyname || "";
          if (
            countyName &&
            countyName !== "í‰ê· " &&
            countyName !== "í‰ë…„" &&
            itemData.itemname
          ) {
            items.push(itemData);
          }
        }
      } else if (errorCode === "000" && !data.data.item) {
        // ì—ëŸ¬ ì½”ë“œëŠ” ì •ìƒì´ì§€ë§Œ itemì´ ì—†ëŠ” ê²½ìš° (í•´ë‹¹ ê¸°ê°„ ë°ì´í„° ì—†ìŒ)
        console.log(
          "â„¹ï¸ [KAMIS API] ì—ëŸ¬ ì½”ë“œëŠ” ì •ìƒì´ì§€ë§Œ í•´ë‹¹ ê¸°ê°„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.",
        );
      }
    } else {
      console.warn(
        "âš ï¸ [KAMIS API] ì˜ˆìƒí•˜ì§€ ëª»í•œ ì‘ë‹µ êµ¬ì¡°:",
        JSON.stringify(data).substring(0, 200),
      );
    }

    return items;
  } catch (error) {
    console.error("âŒ KAMIS API í˜¸ì¶œ ì‹¤íŒ¨:", error);
    throw error;
  }
}

/**
 * KAMIS APIì—ì„œ ëª¨ë“  í’ˆëª© ì •ë³´ ì¡°íšŒ
 * action=productInfo ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš©
 * @returns í’ˆëª© ì •ë³´ ë°°ì—´ (í’ˆëª© ì½”ë“œ, í’ˆëª©ëª…, ë¶€ë¥˜ ì½”ë“œ, ë¶€ë¥˜ëª…)
 */
async function fetchAllKAMISItems(): Promise<
  Array<{
    itemCode: string;
    itemName: string;
    categoryCode: string;
    categoryName: string;
  }>
> {
  const certId = process.env.KAMIS_CERT_ID;
  const certKey = process.env.KAMIS_CERT_KEY?.trim().replace(
    /^["']|["']$/g,
    "",
  );

  if (!certId || !certKey) {
    throw new Error("KAMIS API ì¸ì¦ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
  }

  const baseUrl = "http://www.kamis.or.kr/service/price/xml.do";
  const params = new URLSearchParams({
    action: "productInfo",
    p_cert_key: certKey,
    p_cert_id: certId,
    p_returntype: "json", // JSON í˜•ì‹ìœ¼ë¡œ ìš”ì²­
  });

  const apiUrl = `${baseUrl}?${params.toString()}`;

  try {
    console.log("ğŸ” [KAMIS productInfo] í’ˆëª© ì •ë³´ ì¡°íšŒ ì‹œì‘");
    const response = await fetch(apiUrl, {
      cache: "no-store",
      headers: {
        Accept: "application/json",
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error("âŒ [KAMIS productInfo] API ì˜¤ë¥˜ ì‘ë‹µ:", errorText);
      throw new Error(
        `KAMIS productInfo API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status} ${response.statusText}`,
      );
    }

    // ì‘ë‹µ í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ì½ì–´ì„œ JSONì¸ì§€ XMLì¸ì§€ íŒë‹¨
    const responseText = await response.text();
    let data: any;

    // JSON íŒŒì‹± ì‹œë„ (KAMIS APIëŠ” text/plainìœ¼ë¡œ JSONì„ ë°˜í™˜í•  ìˆ˜ ìˆìŒ)
    try {
      data = JSON.parse(responseText);
      console.log("âœ… [KAMIS productInfo] JSON ì‘ë‹µ íŒŒì‹± ì„±ê³µ");
    } catch (jsonError) {
      // JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ XMLë¡œ ê°„ì£¼
      console.warn(
        "âš ï¸ [KAMIS productInfo] JSON íŒŒì‹± ì‹¤íŒ¨, XMLë¡œ ê°„ì£¼í•˜ì—¬ ì²˜ë¦¬ ì‹œë„...",
      );
      // XML íŒŒì‹±ì€ ê°„ë‹¨í•œ ì •ê·œì‹ìœ¼ë¡œ ì²˜ë¦¬ (í•„ìš”ì‹œ xml2js ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© ê°€ëŠ¥)
      throw new Error(
        `ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: JSONê³¼ XML ëª¨ë‘ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‘ë‹µ ìƒ˜í”Œ: ${responseText.substring(
          0,
          200,
        )}`,
      );
    }

    const items: Array<{
      itemCode: string;
      itemName: string;
      categoryCode: string;
      categoryName: string;
    }> = [];

    // ì‘ë‹µ êµ¬ì¡° íŒŒì‹±
    // ì‹¤ì œ ì‘ë‹µ êµ¬ì¡°: { "error_code": "000", "info": [{ itemcode, itemname, ... }, ...] }
    // infoëŠ” ë°°ì—´ì´ë©°, ê° ìš”ì†Œê°€ í’ˆëª© ì •ë³´ë¥¼ ë‹´ê³  ìˆìŒ
    if (data.info && Array.isArray(data.info)) {
      // ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•œ Set ì‚¬ìš© (í’ˆëª© ì½”ë“œ + í’ˆëª©ëª… ì¡°í•©)
      const seen = new Set<string>();

      for (const item of data.info) {
        const itemCode = item.itemcode || item.itemCode;
        const itemName = item.itemname || item.itemName;
        const categoryCode = item.itemcategorycode || item.itemCategoryCode;
        const categoryName = item.itemcategoryname || item.itemCategoryName;

        if (itemCode && itemName) {
          // ë™ì¼í•œ í’ˆëª© ì½”ë“œì™€ í’ˆëª©ëª… ì¡°í•©ì€ í•œ ë²ˆë§Œ ì¶”ê°€ (í’ˆì¢…ë³„ë¡œ ì—¬ëŸ¬ ê°œê°€ ìˆì„ ìˆ˜ ìˆìŒ)
          const key = `${itemCode}_${itemName}`;
          if (!seen.has(key)) {
            seen.add(key);
            items.push({
              itemCode: String(itemCode),
              itemName: String(itemName),
              categoryCode: String(categoryCode || ""),
              categoryName: String(categoryName || ""),
            });
          }
        }
      }
    } else if (data.info && data.info.item) {
      // XML êµ¬ì¡°ë¥¼ JSONìœ¼ë¡œ ë³€í™˜í•œ ê²½ìš° (í•˜ìœ„ í˜¸í™˜ì„±)
      const itemList = Array.isArray(data.info.item)
        ? data.info.item
        : [data.info.item];

      const seen = new Set<string>();

      for (const item of itemList) {
        const itemCode = item.itemcode || item.itemCode;
        const itemName = item.itemname || item.itemName;
        const categoryCode = item.itemcategorycode || item.itemCategoryCode;
        const categoryName = item.itemcategoryname || item.itemCategoryName;

        if (itemCode && itemName) {
          const key = `${itemCode}_${itemName}`;
          if (!seen.has(key)) {
            seen.add(key);
            items.push({
              itemCode: String(itemCode),
              itemName: String(itemName),
              categoryCode: String(categoryCode || ""),
              categoryName: String(categoryName || ""),
            });
          }
        }
      }
    } else if (data.document && data.document.info && data.document.info.item) {
      // XML êµ¬ì¡°ë¥¼ JSONìœ¼ë¡œ ë³€í™˜í•œ ê²½ìš° (í•˜ìœ„ í˜¸í™˜ì„±)
      const itemList = Array.isArray(data.document.info.item)
        ? data.document.info.item
        : [data.document.info.item];

      const seen = new Set<string>();

      for (const item of itemList) {
        const itemCode = item.itemcode || item.itemCode;
        const itemName = item.itemname || item.itemName;
        const categoryCode = item.itemcategorycode || item.itemCategoryCode;
        const categoryName = item.itemcategoryname || item.itemCategoryName;

        if (itemCode && itemName) {
          const key = `${itemCode}_${itemName}`;
          if (!seen.has(key)) {
            seen.add(key);
            items.push({
              itemCode: String(itemCode),
              itemName: String(itemName),
              categoryCode: String(categoryCode || ""),
              categoryName: String(categoryName || ""),
            });
          }
        }
      }
    } else {
      console.warn(
        "âš ï¸ [KAMIS productInfo] ì˜ˆìƒí•˜ì§€ ëª»í•œ ì‘ë‹µ êµ¬ì¡°:",
        JSON.stringify(data).substring(0, 500),
      );
    }

    console.log(
      `âœ… [KAMIS productInfo] í’ˆëª© ì •ë³´ ì¡°íšŒ ì™„ë£Œ: ${items.length}ê°œ í’ˆëª©`,
    );
    return items;
  } catch (error) {
    console.error("âŒ [KAMIS productInfo] í’ˆëª© ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:", error);
    throw error;
  }
}

/**
 * í’ˆëª© ì •ë³´ ìºì‹œ (ë©”ëª¨ë¦¬)
 * ì„œë²„ ì¬ì‹œì‘ ì‹œ ì´ˆê¸°í™”ë˜ë¯€ë¡œ, í”„ë¡œë•ì…˜ì—ì„œëŠ” Supabase DB ì‚¬ìš© ê¶Œì¥
 */
let kamisItemsCache: Array<{
  itemCode: string;
  itemName: string;
  categoryCode: string;
  categoryName: string;
}> | null = null;

let kamisItemsCacheTime: number = 0;
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24ì‹œê°„

/**
 * ìºì‹œëœ í’ˆëª© ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì—†ìœ¼ë©´ API í˜¸ì¶œ)
 */
async function getKAMISItems(): Promise<
  Array<{
    itemCode: string;
    itemName: string;
    categoryCode: string;
    categoryName: string;
  }>
> {
  const now = Date.now();

  // ìºì‹œê°€ ìˆê³  ìœ íš¨í•˜ë©´ ë°˜í™˜
  if (kamisItemsCache && now - kamisItemsCacheTime < CACHE_DURATION) {
    console.log(
      `ğŸ“¦ [KAMIS Items Cache] ìºì‹œ ì‚¬ìš© (${kamisItemsCache.length}ê°œ í’ˆëª©)`,
    );
    return kamisItemsCache;
  }

  // ìºì‹œê°€ ì—†ê±°ë‚˜ ë§Œë£Œë˜ì—ˆìœ¼ë©´ API í˜¸ì¶œ
  console.log("ğŸ”„ [KAMIS Items Cache] ìºì‹œ ê°±ì‹  ì¤‘...");
  kamisItemsCache = await fetchAllKAMISItems();
  kamisItemsCacheTime = now;

  return kamisItemsCache;
}

/**
 * í’ˆëª©ëª…ìœ¼ë¡œ ì •í™•í•œ í’ˆëª© ì½”ë“œ ì°¾ê¸° (productInfo API í™œìš©)
 * @param itemName - ê²€ìƒ‰í•  í’ˆëª©ëª…
 * @returns í’ˆëª© ì½”ë“œì™€ ë¶€ë¥˜ ì½”ë“œ, ì—†ìœ¼ë©´ null
 */
async function getItemCodeFromNameUsingAPI(
  itemName: string,
): Promise<{ itemCode: string; categoryCode: string } | null> {
  if (!itemName) return null;

  try {
    const items = await getKAMISItems();
    const keyword = itemName.toLowerCase().trim();

    // 1. ì •í™•í•œ ì¼ì¹˜ ìš°ì„ 
    const exactMatch = items.find(
      (item) => item.itemName.toLowerCase() === keyword,
    );
    if (exactMatch) {
      console.log(
        `âœ… [í’ˆëª© ì½”ë“œ ê²€ìƒ‰] ì •í™•í•œ ì¼ì¹˜: "${itemName}" â†’ ì½”ë“œ ${exactMatch.itemCode}, ë¶€ë¥˜ ${exactMatch.categoryCode}`,
      );
      return {
        itemCode: exactMatch.itemCode,
        categoryCode: exactMatch.categoryCode,
      };
    }

    // 2. ë¶€ë¶„ ì¼ì¹˜ ê²€ìƒ‰ (í’ˆëª©ëª…ì— í‚¤ì›Œë“œê°€ í¬í•¨ëœ ê²½ìš°)
    const partialMatches = items.filter((item) =>
      item.itemName.toLowerCase().includes(keyword),
    );

    if (partialMatches.length > 0) {
      // ê°€ì¥ ì§§ì€ ì´ë¦„ì´ ê°€ì¥ ì •í™•í•  ê°€ëŠ¥ì„±ì´ ë†’ìŒ
      const bestMatch = partialMatches.reduce((prev, current) =>
        prev.itemName.length < current.itemName.length ? prev : current,
      );
      console.log(
        `âœ… [í’ˆëª© ì½”ë“œ ê²€ìƒ‰] ë¶€ë¶„ ì¼ì¹˜: "${itemName}" â†’ ì½”ë“œ ${bestMatch.itemCode}, ë¶€ë¥˜ ${bestMatch.categoryCode} (${partialMatches.length}ê°œ í›„ë³´ ì¤‘ ì„ íƒ)`,
      );
      return {
        itemCode: bestMatch.itemCode,
        categoryCode: bestMatch.categoryCode,
      };
    }

    console.warn(
      `âš ï¸ [í’ˆëª© ì½”ë“œ ê²€ìƒ‰] "${itemName}"ì— ëŒ€í•œ í’ˆëª© ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ`,
    );
    return null;
  } catch (error) {
    console.error(`âŒ [í’ˆëª© ì½”ë“œ ê²€ìƒ‰] "${itemName}" ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜:`, error);
    return null;
  }
}

/**
 * í’ˆëª©ëª…ìœ¼ë¡œ í’ˆëª© ì½”ë“œ ì°¾ê¸° (ë ˆê±°ì‹œ í˜¸í™˜ì„± ìœ ì§€)
 * @deprecated getItemCodeFromNameUsingAPIë¥¼ ì‚¬ìš©í•˜ì„¸ìš”
 */
function getItemCodeFromName(itemName: string): string | undefined {
  // ë ˆê±°ì‹œ ì½”ë“œëŠ” ì œê±°í•˜ê³ , getItemCodeFromNameUsingAPIë¡œ ëŒ€ì²´
  // ë™ê¸° í•¨ìˆ˜ê°€ í•„ìš”í•œ ê²½ìš°ë¥¼ ìœ„í•´ ìœ ì§€í•˜ë˜, ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
  return undefined;
}

/**
 * í’ˆëª©ëª…ìœ¼ë¡œ ë¶€ë¥˜ ì½”ë“œ ì°¾ê¸°
 */
function getItemCategoryCodeFromName(itemName: string): string | undefined {
  if (!itemName) return undefined;

  // ê³¼ì¼ë¥˜ (ë¶€ë¥˜ ì½”ë“œ: 200)
  const fruits = [
    "ì‚¬ê³¼",
    "ë°°",
    "í¬ë„",
    "ê°ê·¤",
    "ë”¸ê¸°",
    "ìˆ˜ë°•",
    "ë ˆëª¬",
    "ì˜¤ë Œì§€",
    "ê·¤",
    "ì°¸ì™¸",
    "ë³µìˆ­ì•„",
    "í† ë§ˆí† ",
  ];
  // ì±„ì†Œë¥˜ (ë¶€ë¥˜ ì½”ë“œ: 100)
  const vegetables = [
    "ë°°ì¶”",
    "ì–‘ë°°ì¶”",
    "ë¬´",
    "ê³ ì¶”",
    "ë§ˆëŠ˜",
    "ì–‘íŒŒ",
    "ëŒ€íŒŒ",
    "ìƒì¶”",
    "ì‹œê¸ˆì¹˜",
    "ë‹¹ê·¼",
    "ì˜¤ì´",
    "ë¸Œë¡œì½œë¦¬",
  ];

  const normalizedName = itemName.toLowerCase().trim();

  if (
    fruits.some(
      (f) => f === itemName || normalizedName.includes(f.toLowerCase()),
    )
  ) {
    return "200"; // ê³¼ì¼ë¥˜
  }
  if (
    vegetables.some(
      (v) => v === itemName || normalizedName.includes(v.toLowerCase()),
    )
  ) {
    return "100"; // ì±„ì†Œë¥˜
  }

  return undefined;
}

/**
 * ë¶€ë¥˜ ì½”ë“œì— ë”°ë¥¸ ì¼ë°˜ì ì¸ í’ˆëª© ì½”ë“œ ëª©ë¡ ë°˜í™˜
 *
 * @deprecated productInfo APIë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ë” ì´ìƒ í•„ìš”í•˜ì§€ ì•ŠìŒ
 * í’ˆëª© ì½”ë“œë¥¼ ëª¨ë¥¼ ë•Œ ì—¬ëŸ¬ ì½”ë“œë¥¼ ì‹œë„í•˜ê¸° ìœ„í•´ ì‚¬ìš©í–ˆìœ¼ë‚˜,
 * ì´ì œëŠ” getItemCodeFromNameUsingAPI()ë¥¼ ì‚¬ìš©í•˜ì—¬ ì •í™•í•œ ì½”ë“œë¥¼ ì°¾ìŠµë‹ˆë‹¤.
 */
function getCommonItemCodesForCategory(
  categoryCode: string,
  itemName: string,
): string[] {
  const keyword = itemName.toLowerCase().trim();

  if (categoryCode === "200") {
    // ê³¼ì¼ë¥˜ ì¼ë°˜ì ì¸ í’ˆëª© ì½”ë“œ (ë” ë„“ì€ ë²”ìœ„)
    // KAMIS APIì˜ ì‹¤ì œ ì½”ë“œ ë²”ìœ„ë¥¼ ê³ ë ¤í•˜ì—¬ í™•ì¥
    const allFruitCodes: string[] = [];

    // 200ë²ˆëŒ€ (ê³¼ì¼ë¥˜ ì£¼ìš” ì½”ë“œ) - ë” ë„“ì€ ë²”ìœ„ ì‹œë„
    for (let i = 200; i <= 299; i++) {
      allFruitCodes.push(i.toString());
    }

    // í’ˆëª©ëª…ì— ë”°ë¼ ìš°ì„ ìˆœìœ„ ì¡°ì •
    if (keyword.includes("ì‚¬ê³¼")) {
      // ì‚¬ê³¼ëŠ” ì—¬ëŸ¬ ì½”ë“œë¥¼ ì‹œë„ (211ì´ ì•„ë‹ ìˆ˜ ìˆìŒ)
      // ì‹¤ì œë¡œëŠ” ë” ë§ì€ ì½”ë“œë¥¼ ì‹œë„í•´ì•¼ í•¨
      const appleCodes = [
        "211",
        "210",
        "212",
        "213",
        "214",
        "215",
        "216",
        "217",
        "218",
        "219",
        "220",
        "221",
        "222",
        "223",
        "224",
        "225",
        "226",
        "227",
        "228",
        "229",
        "230",
      ];
      const restCodes = allFruitCodes.filter((c) => !appleCodes.includes(c));
      // ìµœëŒ€ 50ê°œê¹Œì§€ë§Œ ì‹œë„ (ì„±ëŠ¥ ê³ ë ¤)
      return [...appleCodes, ...restCodes.slice(0, 30)];
    }
    if (keyword.includes("ë°°")) {
      const pearCodes = ["213", "214", "215", "216", "217"];
      const restCodes = allFruitCodes.filter((c) => !pearCodes.includes(c));
      return [...pearCodes, ...restCodes.slice(0, 30)];
    }

    // ê¸°ë³¸ì ìœ¼ë¡œ 210-250 ë²”ìœ„ ìš°ì„  ì‹œë„ (ì¼ë°˜ì ì¸ ê³¼ì¼ ì½”ë“œ ë²”ìœ„)
    const priorityCodes: string[] = [];
    for (let i = 210; i <= 250; i++) {
      priorityCodes.push(i.toString());
    }
    const restCodes = allFruitCodes.filter((c) => !priorityCodes.includes(c));
    return [...priorityCodes, ...restCodes.slice(0, 20)]; // ìµœëŒ€ 50ê°œê¹Œì§€ë§Œ ì‹œë„
  }

  if (categoryCode === "100") {
    // ì±„ì†Œë¥˜ ì¼ë°˜ì ì¸ í’ˆëª© ì½”ë“œ (ë” ë„“ì€ ë²”ìœ„)
    const allVegetableCodes: string[] = [];

    // 100ë²ˆëŒ€ (ì±„ì†Œë¥˜ ì£¼ìš” ì½”ë“œ)
    for (let i = 100; i <= 199; i++) {
      allVegetableCodes.push(i.toString());
    }
    // 200ë²ˆëŒ€ì—ë„ ì¼ë¶€ ì±„ì†Œê°€ ìˆì„ ìˆ˜ ìˆìŒ (ì–‘ë°°ì¶”ê°€ 212ë¡œ í™•ì¸ë¨)
    allVegetableCodes.push("212", "213", "214", "215");

    // í’ˆëª©ëª…ì— ë”°ë¼ ìš°ì„ ìˆœìœ„ ì¡°ì •
    if (keyword.includes("ì–‘ë°°ì¶”") || keyword.includes("ë°°ì¶”")) {
      const cabbageCodes = ["212", "111", "112", "113", "114", "115"];
      const restCodes = allVegetableCodes.filter(
        (c) => !cabbageCodes.includes(c),
      );
      return [...cabbageCodes, ...restCodes.slice(0, 30)];
    }

    // ê¸°ë³¸ì ìœ¼ë¡œ 100-130 ë²”ìœ„ ìš°ì„  ì‹œë„
    const priorityCodes: string[] = [];
    for (let i = 100; i <= 130; i++) {
      priorityCodes.push(i.toString());
    }
    priorityCodes.push("212"); // ì–‘ë°°ì¶” ì½”ë“œ ì¶”ê°€
    const restCodes = allVegetableCodes.filter(
      (c) => !priorityCodes.includes(c),
    );
    return [...priorityCodes, ...restCodes.slice(0, 20)]; // ìµœëŒ€ 50ê°œê¹Œì§€ë§Œ ì‹œë„
  }

  return [];
}

/**
 * ê³µê³µ API í˜¸ì¶œ í•¨ìˆ˜ (ë‚´ë¶€ í•¨ìˆ˜) - ë ˆê±°ì‹œ
 *
 * âš ï¸ API ì œì•½ì‚¬í•­:
 * - ì‹¤ì‹œê°„ ê²½ë§¤ ë°ì´í„°ë§Œ ë°˜í™˜ (íŠ¹ì • ì‹œì ì—ëŠ” íŠ¹ì • í’ˆëª©ë§Œ ê±°ë˜)
 * - ëŒ€ë¶„ë¥˜ ì½”ë“œ í•„í„°ë§ ë¯¸ì§€ì› (gds_lclsf_cd íŒŒë¼ë¯¸í„° ë¬´ì‹œë¨)
 * - í’ˆëª© ë‹¤ì–‘ì„± í™•ë³´ë¥¼ ìœ„í•´ dateRange íŒŒë¼ë¯¸í„° ì‚¬ìš© ê¶Œì¥
 */
async function fetchMarketPricesFromAPI(
  params: MarketPriceParams = {},
): Promise<PriceItem[]> {
  // ë‚ ì§œ ë²”ìœ„ê°€ ì§€ì •ëœ ê²½ìš° ì—¬ëŸ¬ ë‚ ì§œì˜ ë°ì´í„°ë¥¼ ì¡°íšŒ
  if (params.dateRange) {
    console.group("ğŸ“Š [API í˜¸ì¶œ] ë‚ ì§œ ë²”ìœ„ ì‹œì„¸ ë°ì´í„° ì¡°íšŒ");
    console.log("ë‚ ì§œ ë²”ìœ„:", params.dateRange.from, "~", params.dateRange.to);

    const allItems: PriceItem[] = [];
    const dates = getDatesInRange(params.dateRange.from, params.dateRange.to);

    console.log("ì¡°íšŒí•  ë‚ ì§œ:", dates);

    for (const date of dates) {
      try {
        // ë‚ ì§œë³„ë¡œ API í˜¸ì¶œ (ì¬ê·€ ë°©ì§€ë¥¼ ìœ„í•´ dateRange ì œê±°)
        const items = await fetchMarketPricesFromAPI({
          ...params,
          dateRange: undefined,
          date: date.replace(/-/g, ""), // YYYYMMDD í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        });
        allItems.push(...items);
        console.log(`${date}: ${items.length}ê±´ ì¡°íšŒ`);

        // API ë¶€í•˜ ë°©ì§€ë¥¼ ìœ„í•œ ë”œë ˆì´ (0.3ì´ˆ)
        await new Promise((resolve) => setTimeout(resolve, 300));
      } catch (error) {
        console.warn(`${date} ì¡°íšŒ ì‹¤íŒ¨:`, error);
        // ì—ëŸ¬ê°€ ë‚˜ë„ ê³„ì† ì§„í–‰
      }
    }

    console.log("ì´ ì¡°íšŒ ê±´ìˆ˜:", allItems.length);
    console.groupEnd();

    // ì¤‘ë³µ ì œê±° (ë™ì¼ í’ˆëª©, ë™ì¼ ë‚ ì§œ, ë™ì¼ ê°€ê²©)
    const uniqueItems = Array.from(
      new Map(
        allItems.map((item) => [
          `${item.itemName}-${item.varietyName}-${item.cfmtnYmd}-${item.avgPrice}`,
          item,
        ]),
      ).values(),
    );

    console.log("ì¤‘ë³µ ì œê±° í›„:", uniqueItems.length, "ê±´");
    return uniqueItems;
  }

  // í™˜ê²½ë³€ìˆ˜ì—ì„œ API í‚¤ ê°€ì ¸ì˜¤ê¸° (ë”°ì˜´í‘œ ì œê±°)
  const rawApiKey = process.env.PUBLIC_DATA_API_KEY;
  const apiKey = rawApiKey?.trim().replace(/^["']|["']$/g, "") || null;

  // ğŸ”§ ì„ì‹œ í…ŒìŠ¤íŠ¸: í™˜ê²½ë³€ìˆ˜ê°€ ì—†ì„ ë•Œ í•˜ë“œì½”ë”©ëœ í‚¤ ì‚¬ìš© (í…ŒìŠ¤íŠ¸ í›„ ì œê±° í•„ìš”)
  const TEST_API_KEY =
    "637bda9c5cbfe57e5f9bd8d403344dc96c3b8ec57e6ad52c980a355a554cffcc";
  const finalApiKey = apiKey || TEST_API_KEY;

  console.group("ğŸ” [market-prices] í™˜ê²½ë³€ìˆ˜ í™•ì¸");
  console.log("í™˜ê²½ë³€ìˆ˜ ì¡´ì¬ ì—¬ë¶€:", !!rawApiKey);
  console.log(
    "í™˜ê²½ë³€ìˆ˜ ì›ë³¸ ê°’:",
    rawApiKey ? `${rawApiKey.substring(0, 10)}...` : "ì—†ìŒ",
  );
  console.log("í™˜ê²½ë³€ìˆ˜ ê¸¸ì´:", rawApiKey?.length || 0);
  console.log("ì²˜ë¦¬ëœ API í‚¤ ê¸¸ì´:", apiKey?.length || 0);
  console.log("ìµœì¢… ì‚¬ìš© API í‚¤ ê¸¸ì´:", finalApiKey?.length || 0);
  console.log(
    "í…ŒìŠ¤íŠ¸ í‚¤ ì‚¬ìš© ì—¬ë¶€:",
    !apiKey
      ? "âš ï¸ ì˜ˆ (í™˜ê²½ë³€ìˆ˜ ì—†ìŒ, í…ŒìŠ¤íŠ¸ í‚¤ ì‚¬ìš©)"
      : "âœ… ì•„ë‹ˆì˜¤ (í™˜ê²½ë³€ìˆ˜ ì‚¬ìš©)",
  );
  console.groupEnd();

  if (!finalApiKey) {
    throw new Error("ê³µê³µë°ì´í„°í¬í„¸ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
  }

  const baseUrl = "https://apis.data.go.kr/B552845/katRealTime/trades";

  // ê¸°ë³¸ íŒŒë¼ë¯¸í„° ì„¤ì •
  const queryParams = new URLSearchParams({
    serviceKey: finalApiKey,
    pageNo: params.pageNo?.toString() || "1",
    numOfRows: params.numOfRows?.toString() || "10",
    returnType: "json",
  });

  // ê²€ìƒ‰ ì¡°ê±´ íŒŒë¼ë¯¸í„° ì¶”ê°€
  if (params.date) {
    queryParams.append("trd_clcln_ymd", params.date);
  }
  // ì£¼ì˜: APIê°€ ì¹´í…Œê³ ë¦¬ ì½”ë“œë¡œ í•„í„°ë§í•´ë„ ì‹¤ì œë¡œëŠ” ë‹¤ë¥¸ ì¹´í…Œê³ ë¦¬ì˜ ë°ì´í„°ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆìŒ
  // ë”°ë¼ì„œ í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œì—ì„œ ì¶”ê°€ í•„í„°ë§ì´ í•„ìš”í•¨
  if (params.lclsfCd) {
    queryParams.append("gds_lclsf_cd", params.lclsfCd);
    console.log("ğŸ” [API í˜¸ì¶œ] ëŒ€ë¶„ë¥˜ ì½”ë“œ í•„í„°:", params.lclsfCd);
  }
  if (params.mclsfCd) {
    queryParams.append("gds_mclsf_cd", params.mclsfCd);
    console.log("ğŸ” [API í˜¸ì¶œ] ì¤‘ë¶„ë¥˜ ì½”ë“œ í•„í„°:", params.mclsfCd);
  }
  if (params.sclsfCd) {
    queryParams.append("gds_sclsf_cd", params.sclsfCd);
  }
  // ğŸ†• ë„ë§¤ì‹œì¥ ì½”ë“œ íŒŒë¼ë¯¸í„°
  if (params.whslMrktCd) {
    queryParams.append("whsl_mrkt_cd", params.whslMrktCd);
  }

  console.group("ğŸ“Š [market-prices] ê³µê³µ API í˜¸ì¶œ");
  console.log("íŒŒë¼ë¯¸í„°:", JSON.stringify(params, null, 2));
  console.log(
    "URL:",
    `${baseUrl}?${queryParams.toString().replace(finalApiKey, "***")}`,
  );
  console.log("API í‚¤ ê¸¸ì´:", finalApiKey.length);
  console.log("ìš”ì²­ ì‹œì‘ ì‹œê°„:", new Date().toISOString());

  const startTime = Date.now();

  try {
    const response = await fetch(`${baseUrl}?${queryParams}`, {
      cache: "no-store",
      headers: {
        Accept: "application/json",
      },
    });

    const fetchDuration = Date.now() - startTime;
    console.log("ğŸ“¡ API ì‘ë‹µ ìˆ˜ì‹ :", {
      ìƒíƒœì½”ë“œ: response.status,
      ìƒíƒœí…ìŠ¤íŠ¸: response.statusText,
      ì†Œìš”ì‹œê°„: `${fetchDuration}ms`,
      ContentType: response.headers.get("content-type"),
    });

    if (!response.ok) {
      // ì‘ë‹µ ë³¸ë¬¸ ì½ê¸° ì‹œë„
      let errorBody = "";
      try {
        errorBody = await response.text();
        console.error("âŒ API ì˜¤ë¥˜ ì‘ë‹µ ë³¸ë¬¸:", errorBody);
      } catch (e) {
        console.error("âŒ ì‘ë‹µ ë³¸ë¬¸ ì½ê¸° ì‹¤íŒ¨:", e);
      }

      throw new Error(
        `API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status} ${response.statusText}${
          errorBody ? ` - ${errorBody.substring(0, 200)}` : ""
        }`,
      );
    }

    let data: ApiResponse;
    try {
      data = await response.json();
    } catch (parseError) {
      console.error("âŒ JSON íŒŒì‹± ì‹¤íŒ¨:", parseError);
      const textResponse = await response.text();
      console.error("ì‘ë‹µ ë³¸ë¬¸ (í…ìŠ¤íŠ¸):", textResponse.substring(0, 500));
      throw new Error(
        `API ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: ${
          parseError instanceof Error ? parseError.message : String(parseError)
        }`,
      );
    }

    console.log("ğŸ“¦ API ì‘ë‹µ ë°ì´í„° êµ¬ì¡°:", {
      hasResponse: !!data.response,
      hasHeader: !!data.response?.header,
      resultCode: data.response?.header?.resultCode,
      resultMsg: data.response?.header?.resultMsg,
      hasBody: !!data.response?.body,
      hasItems: !!data.response?.body?.items,
      totalCount: data.response?.body?.totalCount,
      ì‘ë‹µí‚¤: Object.keys(data),
    });

    // API ì‘ë‹µ í™•ì¸ (ìƒˆ APIëŠ” resultCode "0"ì´ ì •ìƒ)
    if (
      data.response?.header?.resultCode !== "0" &&
      data.response?.header?.resultCode !== "00"
    ) {
      const errorMsg = data.response?.header?.resultMsg || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜";
      const resultCode = data.response?.header?.resultCode || "UNKNOWN";

      console.warn("âš ï¸ API ì‘ë‹µ ì˜¤ë¥˜:", {
        resultCode,
        resultMsg: errorMsg,
        ì „ì²´ì‘ë‹µ: JSON.stringify(data, null, 2),
      });

      throw new Error(`API ì‘ë‹µ ì˜¤ë¥˜ [${resultCode}]: ${errorMsg}`);
    }

    // ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš°
    if (!data.response?.body?.items?.item) {
      console.warn("âš ï¸ ê²½ë§¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤:", {
        totalCount: data.response?.body?.totalCount,
        bodyKeys: Object.keys(data.response?.body || {}),
        itemsKeys: Object.keys(data.response?.body?.items || {}),
      });
      console.groupEnd();
      return [];
    }

    const items = Array.isArray(data.response.body.items.item)
      ? data.response.body.items.item
      : [data.response.body.items.item];

    console.log("ğŸ“‹ ë°ì´í„° ë³€í™˜ ì‹œì‘:", {
      ì›ë³¸í•­ëª©ìˆ˜: items.length,
      ì²«ë²ˆì§¸í•­ëª©í‚¤: items[0] ? Object.keys(items[0]) : [],
    });

    // ì²« ë²ˆì§¸ í•­ëª©ì˜ ì‹¤ì œ ë°ì´í„° êµ¬ì¡° ë¡œê¹… (ë””ë²„ê¹…ìš©)
    if (items.length > 0) {
      console.log("ğŸ“‹ ì²« ë²ˆì§¸ í•­ëª© ìƒ˜í”Œ ë°ì´í„°:", {
        corp_gds_item_nm: items[0].corp_gds_item_nm,
        gds_mclsf_nm: items[0].gds_mclsf_nm,
        gds_sclsf_nm: items[0].gds_sclsf_nm,
        gds_lclsf_nm: items[0].gds_lclsf_nm,
        corp_gds_vrty_nm: items[0].corp_gds_vrty_nm,
        gds_lclsf_cd: items[0].gds_lclsf_cd,
        gds_mclsf_cd: items[0].gds_mclsf_cd,
      });
    }

    // API ì‘ë‹µ ë°ì´í„°ë¥¼ PriceItem í˜•íƒœë¡œ ë³€í™˜
    // ìƒˆ APIëŠ” ê°œë³„ ê±°ë˜ ë°ì´í„°ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ, ë‚™ì°°ê°€ê²©(scsbd_prc)ì„ ì‚¬ìš©
    const result = items
      .map((item: any, index: number) => {
        try {
          const price = parseFloat(item.scsbd_prc || "0");
          const varietyName = item.corp_gds_vrty_nm || "";
          const unitQuantity = parseFloat(item.unit_qty || "1.0");
          const quantity = parseFloat(item.qty || "0");

          const qualityValue = extractQuality(varietyName);

          // ê±°ë˜ì¼ì: scsbd_dt (ë‚™ì°°ì¼ì‹œ)ì—ì„œ ë‚ ì§œ ì¶”ì¶œ, ì—†ìœ¼ë©´ trd_clcln_ymd (ì •ì‚°ì¼ì) ì‚¬ìš©
          // scsbd_dtê°€ ìˆìœ¼ë©´ í•­ìƒ ìš°ì„  ì‚¬ìš© (ì‹¤ì œ ê±°ë˜ì¼)
          let tradeDate = "";
          if (item.scsbd_dt) {
            // scsbd_dt í˜•ì‹: "2025-11-26 15:33:27" -> "2025-11-26"
            const dateMatch = item.scsbd_dt.match(/^(\d{4}-\d{2}-\d{2})/);
            if (dateMatch) {
              tradeDate = dateMatch[1];
            }
          }
          // scsbd_dtê°€ ì—†ì„ ë•Œë§Œ trd_clcln_ymd ì‚¬ìš© (ì •ì‚°ì¼ìëŠ” ê±°ë˜ ë‹¤ìŒ ë‚ ì´ë¯€ë¡œ ìµœí›„ì˜ ìˆ˜ë‹¨)
          if (!tradeDate && item.trd_clcln_ymd) {
            // trd_clcln_ymd í˜•ì‹: "2025-11-27" ë˜ëŠ” "20251127"
            const dateStr = item.trd_clcln_ymd.replace(/-/g, "");
            if (dateStr.length === 8) {
              tradeDate = `${dateStr.substring(0, 4)}-${dateStr.substring(
                4,
                6,
              )}-${dateStr.substring(6, 8)}`;
            } else {
              tradeDate = item.trd_clcln_ymd;
            }
          }

          const priceItem: PriceItem = {
            cfmtnYmd: tradeDate, // ë‚™ì°°ì¼ì‹œì—ì„œ ì¶”ì¶œí•œ ë‚ ì§œ ì‚¬ìš©
            lclsfNm: item.gds_lclsf_nm || "",
            mclsfNm: item.gds_mclsf_nm || "",
            sclsfNm: item.gds_sclsf_nm || "",
            avgPrice: price,
            minPrice: price,
            maxPrice: price,
            source: "public" as const,
            // ğŸ†• ì¶”ê°€ í•„ë“œ
            itemName: item.corp_gds_item_nm || item.gds_mclsf_nm || "",
            varietyName: varietyName,
            marketCode: item.whsl_mrkt_cd || "",
            marketName: item.whsl_mrkt_nm || "",
            // ğŸ†• ë‹¨ìœ„ ë° ìˆ˜ëŸ‰ ì •ë³´
            unitName: item.unit_nm || "",
            unitQuantity: unitQuantity,
            quantity: quantity,
          };

          // ì„ íƒì  í•„ë“œ ì¶”ê°€
          if (qualityValue) priceItem.quality = qualityValue;
          if (item.unit_cd) priceItem.unitCode = item.unit_cd;
          if (item.pkg_cd) priceItem.packageCode = item.pkg_cd;
          if (item.pkg_nm) priceItem.packageName = item.pkg_nm;
          if (item.plor_cd) priceItem.originCode = item.plor_cd;
          if (item.plor_nm) priceItem.originName = item.plor_nm;
          if (item.corp_nm) priceItem.corporationName = item.corp_nm;
          if (item.scsbd_dt) priceItem.auctionDate = item.scsbd_dt;
          if (item.trd_se) priceItem.tradeType = item.trd_se;

          return priceItem;
        } catch (itemError) {
          console.error(
            `âŒ í•­ëª© ${index} ë³€í™˜ ì‹¤íŒ¨:`,
            itemError,
            "ì›ë³¸ ë°ì´í„°:",
            item,
          );
          return null;
        }
      })
      .filter((item): item is PriceItem => item !== null);

    const totalDuration = Date.now() - startTime;
    console.log("âœ… ê³µê³µ API ì„±ê³µ:", {
      í•­ëª©ìˆ˜: result.length,
      ì´ì†Œìš”ì‹œê°„: `${totalDuration}ms`,
      fetchì†Œìš”ì‹œê°„: `${fetchDuration}ms`,
    });
    console.groupEnd();
    return result;
  } catch (error) {
    const totalDuration = Date.now() - startTime;
    console.group("âŒ ê³µê³µ API ì‹¤íŒ¨");
    console.error(
      "ì—ëŸ¬ íƒ€ì…:",
      error instanceof Error ? error.constructor.name : typeof error,
    );
    console.error(
      "ì—ëŸ¬ ë©”ì‹œì§€:",
      error instanceof Error ? error.message : String(error),
    );

    if (error instanceof Error) {
      console.error("ì—ëŸ¬ ìŠ¤íƒ:", error.stack);
      console.error("ì—ëŸ¬ ì´ë¦„:", error.name);
    }

    console.error("ì†Œìš” ì‹œê°„:", `${totalDuration}ms`);
    console.error(
      "ìš”ì²­ URL:",
      `${baseUrl}?${queryParams.toString().replace(finalApiKey, "***")}`,
    );
    console.groupEnd();
    throw error;
  }
}

/**
 * ì‹œì„¸ ì¡°íšŒ í•¨ìˆ˜
 *
 * @param params - ì¡°íšŒ íŒŒë¼ë¯¸í„°
 * @returns ì‹œì„¸ ì •ë³´ ë°°ì—´
 */
export async function getMarketPrices(
  params: MarketPriceParams = {},
): Promise<PriceItem[]> {
  // KAMIS API ì‚¬ìš© (ê¸°ë³¸)
  try {
    return await fetchMarketPricesFromKAMIS(params);
  } catch (kamisError) {
    console.warn("âš ï¸ KAMIS API ì‹¤íŒ¨, ê³µê³µ APIë¡œ fallback:", kamisError);
    // KAMIS ì‹¤íŒ¨ ì‹œ ê³µê³µ APIë¡œ fallback (í•˜ìœ„ í˜¸í™˜ì„±)
    try {
      return await fetchMarketPricesFromAPI(params);
    } catch (publicError) {
      console.error("âŒ ê³µê³µ APIë„ ì‹¤íŒ¨:", publicError);
      throw new Error(
        `ì‹œì„¸ ì¡°íšŒ ì‹¤íŒ¨: KAMIS APIì™€ ê³µê³µ API ëª¨ë‘ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ${
          kamisError instanceof Error ? kamisError.message : String(kamisError)
        }`,
      );
    }
  }
}

/**
 * ì¼ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ (KAMIS API ì‚¬ìš©)
 *
 * @param itemName - í’ˆëª©ëª… (í•„ìˆ˜)
 * @param countryCode - ì§€ì—­ ì½”ë“œ (ì„ íƒ)
 * @param days - ì¡°íšŒ ì¼ìˆ˜ (ê¸°ë³¸ 7ì¼)
 * @returns ë‚ ì§œë³„ í‰ê·  ê°€ê²© ë°°ì—´
 */
export async function getDailyPriceTrend(
  itemName: string,
  countryCode?: string,
  days?: number,
): Promise<PriceTrendItem[]>;
/**
 * ì¼ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ (ë ˆê±°ì‹œ í˜¸í™˜)
 */
export async function getDailyPriceTrend(
  lclsfCd: string,
  mclsfCd?: string,
  sclsfCd?: string,
  itemName?: string,
  days?: number,
): Promise<PriceTrendItem[]>;
export async function getDailyPriceTrend(
  itemNameOrLclsfCd: string,
  countryCodeOrMclsfCd?: string,
  sclsfCdOrDays?: string | number,
  itemNameOrDays?: string | number,
  days?: number,
): Promise<PriceTrendItem[]> {
  // ìƒˆë¡œìš´ ì‹œê·¸ë‹ˆì²˜ ê°ì§€ (ì²« ë²ˆì§¸ íŒŒë¼ë¯¸í„°ê°€ í’ˆëª©ëª…ì¸ ê²½ìš°)
  const isNewSignature =
    typeof countryCodeOrMclsfCd === "string" &&
    (countryCodeOrMclsfCd.length === 4 || countryCodeOrMclsfCd === undefined);

  let itemName: string;
  let countryCode: string | undefined;
  let actualDays: number;

  if (
    isNewSignature &&
    typeof countryCodeOrMclsfCd === "string" &&
    countryCodeOrMclsfCd.length === 4
  ) {
    // ìƒˆë¡œìš´ ì‹œê·¸ë‹ˆì²˜: getDailyPriceTrend(itemName, countryCode?, days?)
    itemName = itemNameOrLclsfCd;
    countryCode = countryCodeOrMclsfCd;
    actualDays = typeof sclsfCdOrDays === "number" ? sclsfCdOrDays : 7;
  } else {
    // ë ˆê±°ì‹œ ì‹œê·¸ë‹ˆì²˜: getDailyPriceTrend(lclsfCd, mclsfCd?, sclsfCd?, itemName?, days?)
    itemName = (itemNameOrDays as string) || itemNameOrLclsfCd;
    actualDays =
      days || (typeof itemNameOrDays === "number" ? itemNameOrDays : 7);
  }

  const today = new Date();
  const startDate = new Date(today);
  startDate.setDate(today.getDate() - actualDays);

  const startDay = startDate.toISOString().split("T")[0];
  const endDay = today.toISOString().split("T")[0];

  console.group("ğŸ“Š [getDailyPriceTrend] ì¼ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ (KAMIS)");
  console.log("í’ˆëª©ëª…:", itemName);
  console.log("ì§€ì—­ ì½”ë“œ:", countryCode || "ì „ì²´");
  console.log("ì¡°íšŒ ì¼ìˆ˜:", actualDays);
  console.log("ë‚ ì§œ ë²”ìœ„:", startDay, "~", endDay);

  try {
    // KAMIS APIë¡œ ê¸°ê°„ë³„ ë°ì´í„° ì¡°íšŒ
    const prices = await fetchMarketPricesFromKAMIS({
      itemName,
      countryCode,
      startDay,
      endDay,
    });

    // ë‚ ì§œë³„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ í‰ê·  ê°€ê²© ê³„ì‚°
    const priceByDate = new Map<string, number[]>();

    prices.forEach((item) => {
      const date = item.cfmtnYmd;
      if (date) {
        if (!priceByDate.has(date)) {
          priceByDate.set(date, []);
        }
        priceByDate.get(date)!.push(item.avgPrice);
      }
    });

    const results: PriceTrendItem[] = [];
    priceByDate.forEach((prices, date) => {
      const avgPrice = prices.reduce((sum, p) => sum + p, 0) / prices.length;
      results.push({
        date,
        price: Math.round(avgPrice),
        source: "kamis",
      });
    });

    // ë‚ ì§œìˆœ ì •ë ¬
    results.sort((a, b) => a.date.localeCompare(b.date));

    console.log("âœ… ì¼ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ ì™„ë£Œ:", results.length, "ì¼");
    console.groupEnd();

    return results;
  } catch (error) {
    console.error("âŒ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ ì‹¤íŒ¨:", error);
    console.groupEnd();
    throw error;
  }
}

/**
 * ì›”ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ
 *
 * @param lclsfCd - ëŒ€ë¶„ë¥˜ ì½”ë“œ
 * @param mclsfCd - ì¤‘ë¶„ë¥˜ ì½”ë“œ (ì„ íƒ)
 * @param sclsfCd - ì†Œë¶„ë¥˜ ì½”ë“œ (ì„ íƒ)
 * @param itemName - í’ˆëª©ëª… (ì„ íƒ, í•„í„°ë§ìš©)
 * @param months - ì¡°íšŒ ì›”ìˆ˜ (ê¸°ë³¸ 12ê°œì›”)
 * @returns ì›”ë³„ í‰ê·  ê°€ê²© ë°°ì—´
 */
export async function getMonthlyPriceTrend(
  lclsfCd: string,
  mclsfCd?: string,
  sclsfCd?: string,
  itemName?: string,
  months: number = 12,
): Promise<PriceTrendItem[]> {
  const results: PriceTrendItem[] = [];
  const today = new Date();

  console.group("ğŸ“Š [getMonthlyPriceTrend] ì›”ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ");
  console.log("ëŒ€ë¶„ë¥˜ ì½”ë“œ:", lclsfCd);
  console.log("ì¡°íšŒ ì›”ìˆ˜:", months);
  console.log("í’ˆëª©ëª… í•„í„°:", itemName || "ì—†ìŒ");

  for (let i = 0; i < months; i++) {
    const date = new Date(today);
    date.setMonth(date.getMonth() - i);

    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const monthKey = `${year}-${month}`;

    // í•´ë‹¹ ì›”ì˜ ëª¨ë“  ë°ì´í„° ìˆ˜ì§‘ (ë§¤ì¼ ì¡°íšŒ)
    const monthPrices: number[] = [];
    const daysInMonth = new Date(year, parseInt(month), 0).getDate();

    for (let day = 1; day <= daysInMonth; day++) {
      const dayStr = String(day).padStart(2, "0");
      const dateString = `${year}${month}${dayStr}`;

      try {
        const prices = await getMarketPrices({
          date: dateString,
          lclsfCd,
          mclsfCd,
          sclsfCd,
          numOfRows: 1000,
        });

        // í’ˆëª©ëª… í•„í„°ë§ (ìˆëŠ” ê²½ìš°)
        let filteredPrices = prices;
        if (itemName) {
          const keyword = itemName.toLowerCase();
          filteredPrices = prices.filter(
            (p) =>
              p.itemName.toLowerCase().includes(keyword) ||
              p.varietyName.toLowerCase().includes(keyword) ||
              p.mclsfNm.toLowerCase().includes(keyword),
          );
        }

        if (filteredPrices.length > 0) {
          const avgPrice =
            filteredPrices.reduce((sum, p) => sum + p.avgPrice, 0) /
            filteredPrices.length;
          monthPrices.push(avgPrice);
        }
      } catch (error) {
        // ì¼ë¶€ ë‚ ì§œ ì‹¤íŒ¨ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
        console.warn(`${dateString} ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨:`, error);
      }
    }

    if (monthPrices.length > 0) {
      const monthlyAvg =
        monthPrices.reduce((sum, p) => sum + p, 0) / monthPrices.length;
      results.push({
        date: monthKey,
        price: Math.round(monthlyAvg),
        source: "public",
      });
    }
  }

  console.log("âœ… ì›”ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ ì™„ë£Œ:", results.length, "ê°œì›”");
  console.groupEnd();

  return results.reverse(); // ì˜¤ë˜ëœ ì›”ë¶€í„° ì •ë ¬
}

/**
 * ì—°ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ
 *
 * @param lclsfCd - ëŒ€ë¶„ë¥˜ ì½”ë“œ
 * @param mclsfCd - ì¤‘ë¶„ë¥˜ ì½”ë“œ (ì„ íƒ)
 * @param sclsfCd - ì†Œë¶„ë¥˜ ì½”ë“œ (ì„ íƒ)
 * @param itemName - í’ˆëª©ëª… (ì„ íƒ, í•„í„°ë§ìš©)
 * @param years - ì¡°íšŒ ì—°ìˆ˜ (ê¸°ë³¸ 5ë…„)
 * @returns ì—°ë³„ í‰ê·  ê°€ê²© ë°°ì—´
 */
export async function getYearlyPriceTrend(
  lclsfCd: string,
  mclsfCd?: string,
  sclsfCd?: string,
  itemName?: string,
  years: number = 5,
): Promise<PriceTrendItem[]> {
  const results: PriceTrendItem[] = [];
  const today = new Date();

  console.group("ğŸ“Š [getYearlyPriceTrend] ì—°ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ");
  console.log("ëŒ€ë¶„ë¥˜ ì½”ë“œ:", lclsfCd);
  console.log("ì¡°íšŒ ì—°ìˆ˜:", years);
  console.log("í’ˆëª©ëª… í•„í„°:", itemName || "ì—†ìŒ");

  for (let i = 0; i < years; i++) {
    const date = new Date(today);
    date.setFullYear(date.getFullYear() - i);

    const year = date.getFullYear();
    const yearKey = `${year}`;

    // í•´ë‹¹ ì—°ë„ì˜ ëª¨ë“  ë°ì´í„° ìˆ˜ì§‘ (ì›”ë³„ë¡œ ìƒ˜í”Œë§)
    const yearPrices: number[] = [];

    // ê° ì›”ì˜ ì¤‘ê°„ ë‚ ì§œë¥¼ ìƒ˜í”Œë¡œ ì¡°íšŒ (ì„±ëŠ¥ ìµœì í™”)
    for (let month = 1; month <= 12; month++) {
      const monthStr = String(month).padStart(2, "0");
      const dayStr = "15"; // ì›” ì¤‘ê°„ ë‚ ì§œ
      const dateString = `${year}${monthStr}${dayStr}`;

      try {
        const prices = await getMarketPrices({
          date: dateString,
          lclsfCd,
          mclsfCd,
          sclsfCd,
          numOfRows: 1000,
        });

        // í’ˆëª©ëª… í•„í„°ë§ (ìˆëŠ” ê²½ìš°)
        let filteredPrices = prices;
        if (itemName) {
          const keyword = itemName.toLowerCase();
          filteredPrices = prices.filter(
            (p) =>
              p.itemName.toLowerCase().includes(keyword) ||
              p.varietyName.toLowerCase().includes(keyword) ||
              p.mclsfNm.toLowerCase().includes(keyword),
          );
        }

        if (filteredPrices.length > 0) {
          const avgPrice =
            filteredPrices.reduce((sum, p) => sum + p.avgPrice, 0) /
            filteredPrices.length;
          yearPrices.push(avgPrice);
        }
      } catch (error) {
        // ì¼ë¶€ ë‚ ì§œ ì‹¤íŒ¨ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
        console.warn(`${dateString} ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨:`, error);
      }
    }

    if (yearPrices.length > 0) {
      const yearlyAvg =
        yearPrices.reduce((sum, p) => sum + p, 0) / yearPrices.length;
      results.push({
        date: yearKey,
        price: Math.round(yearlyAvg),
        source: "public",
      });
    }
  }

  console.log("âœ… ì—°ë³„ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ ì™„ë£Œ:", results.length, "ë…„");
  console.groupEnd();

  return results.reverse(); // ì˜¤ë˜ëœ ì—°ë„ë¶€í„° ì •ë ¬
}

/**
 * ì¼ì£¼ì¼ ì‹œì„¸ ì¶”ì´ ì¡°íšŒ (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)
 *
 * @deprecated getDailyPriceTrendë¥¼ ì‚¬ìš©í•˜ì„¸ìš”
 */
export async function getPriceTrend(
  lclsfCd: string,
  mclsfCd?: string,
  sclsfCd?: string,
  days: number = 7,
): Promise<PriceTrendItem[]> {
  return await getDailyPriceTrend(lclsfCd, mclsfCd, sclsfCd, undefined, days);
}

// í´ë¼ì´ì–¸íŠ¸ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥í•œ ìœ í‹¸ë¦¬í‹°ëŠ” market-prices-utils.tsë¡œ ì´ë™
// í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ ë‹¤ì‹œ export
export { kamisCountryCodes } from "./market-prices-utils";

/**
 * ì „êµ­ ì£¼ìš” ë„ë§¤ì‹œì¥ ì½”ë“œ ë§¤í•‘ (ë ˆê±°ì‹œ - ê³µê³µ APIìš©)
 * ì „êµ­ ê³µì˜ë„ë§¤ì‹œì¥ ì‹¤ì‹œê°„ ê²½ë§¤ì •ë³´ API ê¸°ì¤€
 *
 * ì£¼ìš” ë„ë§¤ì‹œì¥:
 * - ì„œìš¸: ê°€ë½ì‹œì¥ (ì†¡íŒŒêµ¬), ê°•ì„œì‹œì¥, ë…¸ëŸ‰ì§„ìˆ˜ì‚°ì‹œì¥
 * - ë¶€ì‚°: ì—„ê¶ì‹œì¥, ë°˜ì—¬ë†ì‚°ë¬¼ì‹œì¥
 * - ê¸°íƒ€ ì§€ì—­ë³„ ì¤‘ì•™ë†ìˆ˜ì‚°ë¬¼ë„ë§¤ì‹œì¥
 */
export const majorMarketCodes = {
  ì „ì²´: undefined,
  "ì„œìš¸(ê°€ë½)": "110001",
  "ë¶€ì‚°(ì—„ê¶)": "210001",
  "ëŒ€êµ¬(ë¶ë¶€)": "220001",
  "ì¸ì²œ(êµ¬ì›”)": "230001",
  ê´‘ì£¼: "250001",
  ëŒ€ì „: "240001",
  ìš¸ì‚°: "260001",
  "ê²½ê¸°(ìˆ˜ì›)": "410001",
  "ê°•ì›(ì¶˜ì²œ)": "420001",
  "ì¶©ë¶(ì²­ì£¼)": "430001",
  "ì¶©ë‚¨(ì²œì•ˆ)": "440001",
  "ì „ë¶(ì „ì£¼)": "450001",
  "ì „ë‚¨(ëª©í¬)": "460001",
  "ê²½ë¶(ì•ˆë™)": "470001",
  "ê²½ë‚¨(ì§„ì£¼)": "480001",
  ì œì£¼: "500001",
} as const;

/**
 * í’ˆì§ˆ ë“±ê¸‰ ì¶”ì¶œ í•¨ìˆ˜
 * í’ˆì¢…ëª…ì—ì„œ í’ˆì§ˆ ë“±ê¸‰ ì •ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤ (íŠ¹/ìƒ/ì¤‘/í•˜)
 */
export function extractQuality(varietyName: string): string | undefined {
  if (!varietyName) return undefined;

  // íŒ¨í„´: "íŠ¹", "ìƒ", "ì¤‘", "í•˜", "(íŠ¹)", "(ìƒ)", "íŠ¹í’ˆ", "ìƒí’ˆ" ë“±
  const patterns = [
    /\(íŠ¹\)/,
    /\(ìƒ\)/,
    /\(ì¤‘\)/,
    /\(í•˜\)/,
    /íŠ¹ê¸‰/,
    /íŠ¹í’ˆ/,
    /ìƒí’ˆ/,
    /ì¤‘í’ˆ/,
    /\síŠ¹\s/,
    /\sìƒ\s/,
    /\sì¤‘\s/,
    /\sí•˜\s/,
  ];

  for (const pattern of patterns) {
    const match = varietyName.match(pattern);
    if (match) {
      // "íŠ¹", "ìƒ", "ì¤‘", "í•˜"ë¡œ ì •ê·œí™”
      const quality = match[0].replace(/[()í’ˆê¸‰\s]/g, "");
      if (["íŠ¹", "ìƒ", "ì¤‘", "í•˜"].includes(quality)) {
        return quality;
      }
    }
  }

  return undefined;
}

/**
 * ì£¼ìš” í’ˆëª© ì¹´í…Œê³ ë¦¬ (ëŒ€ë¶„ë¥˜ ì½”ë“œ ë§¤í•‘)
 * ì „êµ­ ê³µì˜ë„ë§¤ì‹œì¥ ì‹¤ì‹œê°„ ê²½ë§¤ì •ë³´ API ê¸°ì¤€
 */
export const itemCategories = {
  ì±„ì†Œë¥˜: {
    code: "10",
    items: ["ë°°ì¶”", "ë¬´", "ê³ ì¶”", "ë§ˆëŠ˜", "ì–‘íŒŒ", "ëŒ€íŒŒ"],
  },
  ê³¼ì‹¤ë¥˜: {
    code: "06",
    items: ["ì‚¬ê³¼", "ë°°", "í¬ë„", "ê°ê·¤", "ë”¸ê¸°", "ìˆ˜ë°•", "ë ˆëª¬"],
  },
  ì¶•ì‚°ë¬¼: {
    code: "03",
    items: ["ì‡ ê³ ê¸°", "ë¼ì§€ê³ ê¸°", "ë‹­ê³ ê¸°"],
  },
} as const;

// í´ë¼ì´ì–¸íŠ¸ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥í•œ ìœ í‹¸ë¦¬í‹°ëŠ” market-prices-utils.tsë¡œ ì´ë™
// í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ ë‹¤ì‹œ export
export {
  itemNameToCategory,
  getCategoryFromKeyword,
} from "./market-prices-utils";
